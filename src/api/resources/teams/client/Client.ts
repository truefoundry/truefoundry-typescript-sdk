// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as errors from "../../../../errors/index.js";
import * as TrueFoundry from "../../../index.js";

export declare namespace Teams {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Teams {
    protected readonly _options: Teams.Options;

    constructor(_options: Teams.Options) {
        this._options = _options;
    }

    /**
     * Retrieve all teams associated with the authenticated user. If the user is a tenant admin, returns all teams for the tenant. Pagination is available based on query parameters
     *
     * @param {TrueFoundry.TeamsListRequest} request
     * @param {Teams.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.teams.list({
     *         limit: 10,
     *         offset: 0,
     *         type: "team"
     *     })
     */
    public async list(
        request: TrueFoundry.TeamsListRequest = {},
        requestOptions?: Teams.RequestOptions,
    ): Promise<core.Page<TrueFoundry.Team, TrueFoundry.ListTeamsResponse>> {
        const list = core.HttpResponsePromise.interceptFunction(
            async (
                request: TrueFoundry.TeamsListRequest,
            ): Promise<core.WithRawResponse<TrueFoundry.ListTeamsResponse>> => {
                const { limit = 100, offset = 0, type: type_ } = request;
                const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
                if (limit != null) {
                    _queryParams.limit = limit.toString();
                }
                if (offset != null) {
                    _queryParams.offset = offset.toString();
                }
                if (type_ != null) {
                    _queryParams.type = type_;
                }
                const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
                    this._options?.headers,
                    mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                    requestOptions?.headers,
                );
                const _response = await (this._options.fetcher ?? core.fetcher)({
                    url: core.url.join(
                        (await core.Supplier.get(this._options.baseUrl)) ??
                            (await core.Supplier.get(this._options.environment)),
                        "api/svc/v1/teams/user",
                    ),
                    method: "GET",
                    headers: _headers,
                    queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
                    timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
                    maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
                    abortSignal: requestOptions?.abortSignal,
                });
                if (_response.ok) {
                    return {
                        data: _response.body as TrueFoundry.ListTeamsResponse,
                        rawResponse: _response.rawResponse,
                    };
                }
                if (_response.error.reason === "status-code") {
                    throw new errors.TrueFoundryError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
                }
                switch (_response.error.reason) {
                    case "non-json":
                        throw new errors.TrueFoundryError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.rawBody,
                            rawResponse: _response.rawResponse,
                        });
                    case "timeout":
                        throw new errors.TrueFoundryTimeoutError(
                            "Timeout exceeded when calling GET /api/svc/v1/teams/user.",
                        );
                    case "unknown":
                        throw new errors.TrueFoundryError({
                            message: _response.error.errorMessage,
                            rawResponse: _response.rawResponse,
                        });
                }
            },
        );
        let _offset = request?.offset != null ? request?.offset : 0;
        const dataWithRawResponse = await list(request).withRawResponse();
        return new core.Page<TrueFoundry.Team, TrueFoundry.ListTeamsResponse>({
            response: dataWithRawResponse.data,
            rawResponse: dataWithRawResponse.rawResponse,
            hasNextPage: (response) => (response?.data ?? []).length >= (request?.limit ?? 1),
            getItems: (response) => response?.data ?? [],
            loadPage: (response) => {
                _offset += response?.data != null ? response.data.length : 1;
                return list(core.setObjectProperty(request, "offset", _offset));
            },
        });
    }

    /**
     * Creates a new team or updates an existing team. It ensures that the team name is unique, valid, and that the team has at least one member. The members of the team are added or updated based on the provided emails.
     *
     * @param {TrueFoundry.ApplyTeamRequest} request
     * @param {Teams.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link TrueFoundry.ConflictError}
     * @throws {@link TrueFoundry.UnprocessableEntityError}
     *
     * @example
     *     await client.teams.createOrUpdate({
     *         manifest: {
     *             type: "team",
     *             name: "name",
     *             members: ["members"]
     *         }
     *     })
     */
    public createOrUpdate(
        request: TrueFoundry.ApplyTeamRequest,
        requestOptions?: Teams.RequestOptions,
    ): core.HttpResponsePromise<TrueFoundry.GetTeamResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createOrUpdate(request, requestOptions));
    }

    private async __createOrUpdate(
        request: TrueFoundry.ApplyTeamRequest,
        requestOptions?: Teams.RequestOptions,
    ): Promise<core.WithRawResponse<TrueFoundry.GetTeamResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                "api/svc/v1/teams",
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as TrueFoundry.GetTeamResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 409:
                    throw new TrueFoundry.ConflictError(
                        _response.error.body as TrueFoundry.HttpError,
                        _response.rawResponse,
                    );
                case 422:
                    throw new TrueFoundry.UnprocessableEntityError(
                        _response.error.body as unknown,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.TrueFoundryError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TrueFoundryError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TrueFoundryTimeoutError("Timeout exceeded when calling PUT /api/svc/v1/teams.");
            case "unknown":
                throw new errors.TrueFoundryError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get Team associated with provided team id
     *
     * @param {string} id - Team Id
     * @param {Teams.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link TrueFoundry.NotFoundError}
     *
     * @example
     *     await client.teams.get("id")
     */
    public get(
        id: string,
        requestOptions?: Teams.RequestOptions,
    ): core.HttpResponsePromise<TrueFoundry.GetTeamResponse> {
        return core.HttpResponsePromise.fromPromise(this.__get(id, requestOptions));
    }

    private async __get(
        id: string,
        requestOptions?: Teams.RequestOptions,
    ): Promise<core.WithRawResponse<TrueFoundry.GetTeamResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `api/svc/v1/teams/${core.url.encodePathParam(id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as TrueFoundry.GetTeamResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new TrueFoundry.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                default:
                    throw new errors.TrueFoundryError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TrueFoundryError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TrueFoundryTimeoutError("Timeout exceeded when calling GET /api/svc/v1/teams/{id}.");
            case "unknown":
                throw new errors.TrueFoundryError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Deletes the Team associated with the provided Id.
     *
     * @param {string} id - Team Id
     * @param {Teams.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link TrueFoundry.NotFoundError}
     * @throws {@link TrueFoundry.ConflictError}
     *
     * @example
     *     await client.teams.delete("id")
     */
    public delete(
        id: string,
        requestOptions?: Teams.RequestOptions,
    ): core.HttpResponsePromise<TrueFoundry.DeleteTeamResponse> {
        return core.HttpResponsePromise.fromPromise(this.__delete(id, requestOptions));
    }

    private async __delete(
        id: string,
        requestOptions?: Teams.RequestOptions,
    ): Promise<core.WithRawResponse<TrueFoundry.DeleteTeamResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)),
                `api/svc/v1/teams/${core.url.encodePathParam(id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as TrueFoundry.DeleteTeamResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 404:
                    throw new TrueFoundry.NotFoundError(_response.error.body as unknown, _response.rawResponse);
                case 409:
                    throw new TrueFoundry.ConflictError(
                        _response.error.body as TrueFoundry.HttpError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.TrueFoundryError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.TrueFoundryError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.TrueFoundryTimeoutError(
                    "Timeout exceeded when calling DELETE /api/svc/v1/teams/{id}.",
                );
            case "unknown":
                throw new errors.TrueFoundryError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        const bearer = (await core.Supplier.get(this._options.apiKey)) ?? process?.env.TFY_API_KEY;
        if (bearer == null) {
            throw new errors.TrueFoundryError({
                message:
                    "Please specify a bearer by either passing it in to the constructor or initializing a TFY_API_KEY environment variable",
            });
        }

        return `Bearer ${bearer}`;
    }
}
